/*
* generated by Xtext
*/
package it.marcotinacci.xturing.ui.outline;

import it.marcotinacci.xturing.xTuring.Machine;
import it.marcotinacci.xturing.xTuring.ReadWriteSymbol;
import it.marcotinacci.xturing.xTuring.State;
import it.marcotinacci.xturing.xTuring.Symbol;
import it.marcotinacci.xturing.xTuring.Transaction;
import it.marcotinacci.xturing.xTuring.XTuringPackage;

import org.eclipse.xtext.ui.IImageHelper;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
import org.eclipse.xtext.ui.editor.outline.impl.EObjectNode;

import com.google.inject.Inject;

/**
 * customization of the default outline structure
 * 
 */
public class XTuringOutlineTreeProvider extends DefaultOutlineTreeProvider {

	@Inject
	private IImageHelper imageHelper;
	
	protected void _createChildren(DocumentRootNode parentNode, Machine machine) {
		// symbols section
		createEStructuralFeatureNode(
				parentNode, 
				machine, 
				XTuringPackage.Literals.MACHINE__SYMBOLS, 
				null,
				"Alphabet", 
				false
			);
		
		// states section
		createEStructuralFeatureNode(
				parentNode, 
				machine, 
				XTuringPackage.Literals.MACHINE__STATES, 
				null,
				"States", 
				false
			);
	}
	
	protected void _createNode(IOutlineNode parentNode, State state){
		EObjectNode node1 = createEObjectNode(parentNode, state, 
				state.isBeginState() ? imageHelper.getImage("begin_state.gif") : imageHelper.getImage("state.gif"),
				state.getName(), false);
		// i: transaction counter
		int i = 1;
		// for each transaction of the state
		for (Transaction transaction : state.getTransactions()) {
			// create a node for the transaction
			EObjectNode node2 = createEObjectNode(node1, transaction, null, "transaction "+i, false);
			
			if(transaction.isReading()){
				// for each symbol read
				for (ReadWriteSymbol sym : transaction.getRead()) {
					// create a node for the readed symbol
					createEObjectNode(node2, sym, null, 
							"read "+(sym.getSymbol()==null ? '~' : sym.getSymbol().getName()), true);					
				}
			}else{
				createEObjectNode(node2, transaction, null, "read *", true);
			}
			
			if(transaction.isWriting()){
				// for each symbol write
				for (ReadWriteSymbol sym : transaction.getWrite()) {
					// create a node for the writed symbol
					createEObjectNode(node2, sym, null, 
							"write "+(sym.getSymbol()==null ? '~' : sym.getSymbol().getName()), true);					
				}
			}else{
				createEObjectNode(node2, transaction, null, "do not write", true);
			}
			
			if(transaction.isMoving()){
				createEObjectNode(node2, transaction, null, 
						"move "+(transaction.getMove().equals("LEFT") ? "left" : "right"), true);
			}else{
				createEObjectNode(node2, transaction, null, "do not move", true);
			}
			
			if(transaction.isNext()){
				createEObjectNode(node2, transaction.getToState(), null, "next state: "+transaction.getToState().getName(), true);
				
			}else if(transaction.isFinal()){
				createEObjectNode(node2, transaction.getToState(), null, "terminate", true);
			}else{
				createEObjectNode(node2, state, null, "next state: "+state.getName(), true);
			}
			
			i++;
		}
	}
	
	protected boolean _isLeaf(Symbol symbol) {
	    return true;
	}
	protected boolean _isLeaf(State state) {
	    return false;
	}
}
